# Handwritten Equation Solver
## Capstone Project for DSI 919

### Problem Statement

Computer Vision is one of the fastest growing fields in Machine Learning. Among this, Handwritten Text Recognition, or HTR, is one of the most in demand. This field is interesting in that it is already widely used, but still not perfected. This is because of various problems inherant with this application. One is correctly parsing an image into seperate characters or symbols, and another is classifying the characters into text. The second is particularly difficult due to variations and imperfections in handwritting. I decided to use my knowledge to create a handwritten equation solver that will attempt to perform both of these functions on a handwritten equation, and solve the resulting output. Although I am unlikely to make a perfect version of this difficult application, I hope that my research can contribute in some small way to the larger research of computer vision. 

### Data Structure
The data I used to train my model was obtained from a [kaggle dataset](https://www.kaggle.com/datasets/xainano/handwrittenmathsymbols) containing over 500,000 handwritten mathematical symbols. I decided to use the 10 numerical digits, multiplication, subtraction, and addition symbols. Division symbols were problematic in that they came in two different forms and were hard to classify. This constituted about 200,000 images. There was some class imbalances in the data, but I found that when I manually balanced the classes, my misclassification rate increased, so they were kept as is.

Testing data was created manually using GNU Image Manipulation Program, an program similar to MS Paint where equations can be hand drawn. 20 Equations were used for testing.

### File Structure
#### code directory
Contains 5 jupyter notebooks which constitute this project and are described below. 2 python scripts "image_parsing.py" and "prediction_and_solving.py" can be run in that order for demonstration. Images placed in the equation_input directory with the filename "test.jpeg" will be parsed, predicted and solved using this code.

#### image_data directory
Contains all image data used for this project. Images can be placed in "equation_input" with the filename "test.jpeg" for demonstration purposes. Other test equations can be found in "test_equations". These can be processed by changing the "image_path" variable in the "04_Equation_Image_Cropping" notebook or the "image_parsing.py" script. Seperated and cropped images generated by the image parsing code is saved to the "image_output" folder.

The "processed_images" folder contains images generated during the parsing process, such as images showing the bounding boxes used to crop the equation image. "training_images" contains all images used to train the CNN. "validation_images" contains a set of 200 images of each class and was used for validating the models.

#### models directory
This directory contains pickled CNNs trained for this project. "cnn_3layer64dropout.pkl" is the model used for final predictions

#### visualizations directory
This directory contains visualizations generated from EDA and model validation.

### Workflow
#### 01_EDA.ipynb
This notebook contains code exploring the directories in the "training_images" folder. Includes counts and visualizations of different classes and sample images of handwritten symbols

#### 02_CNN_Training.ipynb
This notebook contains code used to load in image data and train a CNN, print visualizations of the training process, and pickle the CNN to the "models" directory. Several CNNs were trained in this fashion. The final CNN used is currently in the code.

#### 03_Model_Validation.ipynb
This notebook contains code to load in several pickled CNNs, generate predictions of the validation set, and compute accuracy. It also generates a confusion matrix based on validation set predictions.

#### 04_Equation_Image_Cropping.ipynb
This notebook will load in an equation image from the "equation_input" folder, and use the OpenCV library to draw bounding boxes around seperate symbols, and crop them into seperate images. Some of this code was adapted from an [appsloveworld](https://www.appsloveworld.com/opencv/100/73/python-split-an-image-based-on-white-space) article showing how images can be cropped based on contours. Resulting cropped images are saved to the "image_output" folder.

#### 05_Prediction_and_Solving.ipynb
This notebook loads in the final pickled CNN as well as the cropped images from the "image_output" folder, and predicts each image in order. The output from this model is translated back to numbers and symbols, and the resulting equation is solved and printed.

### Conclusions

This project was very educational and taught me much of the computer vision field. The library OpenCV was vital to this process. Several features of this library were useful for image manipulation, visualization, and cropping. The cropped images had to be sized very carefully in order to be reshaped in a form that could be interpreted by the trained CNN. 
